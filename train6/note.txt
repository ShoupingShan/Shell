基本正则表达式
1.行首定位符"^"
  "^"用来匹配行首的字符,表示行首的字符是"^"后面的那个字符.正则表达式
  的定位符的作用元字符的作用不同,它们不是用来匹配具体的文字,而是匹配某
  个具体的位置,例如行首定位符"^"就是用来匹配文本航的开头的字符串的.
  str=`ls /etc|grep "^po"`
  echo "$str"

2.行尾定位符"$"
  行尾定位符的作用是用来定位文本行的末尾的.从语法上讲,行尾定位符的位置
  也与行首定位符相反,行首定位符位于所作用的字符之前,而行尾定位符位于所
  作用的字符之后.
  echo "行尾定位符"
  str=`ls /etc | grep "conf$"`
  echo "$str"

3.单个字符匹配"."
  圆点"."用来匹配任意单个字符,包括空格,但是不包括换行符"\n".当用户使
  用"."符号后,意味着该位置一定有一个字符,无论它是什么字符.
  echo "单个字符匹配"
  str=`ls /etc | grep "samba"`
  echo "$str"
  echo "========================"
  str=`ls /etc | grep "samba."`
  echo "$str"

4.限定符"*"
  星号"*"是正则表达式中的限定符之一.限定符本身不代表任何字符,它是用来
  指定其前面的一个字符必须重复出现多少次才能满足匹配.星号"*"表示匹配其
  前导字符的任意次数,包括0次.
  #筛选出以字符s开头,紧接着一个字符s,任意个字符s的文件名
  str=`ls /etc | grep "^sss*"`
  echo "$str"

5.字符集匹配"[]"
  方括号"[]"的功能比较特殊,它是用来指定一个字符合集的,其基本语法为:
  [abc]
  其中a,b和c表示任意的单个字符.只要某个字符在方括号所在的位置上出现了
  方括号中的任意一个字符,就都满足匹配规则.另外,对于连续的数字或者字母,
  可以使用连字符"-"来表示一个范围,例如"[a-f]"表示匹配字母表中a到f中
  任意一个字母,而"[0-9]"表示匹配任意单个数字.

  #筛选出所有以字符r开头,并且紧跟着一个字符c的文本行
  str=`ls /etc | grep "^rc"`
  echo "$str"
  echo "======================="
  #筛选出所有以字符r开头,紧跟着一个字符c,下面1个字符为单个数字的文本行
  str=`ls /etc | grep "^rc[0-9]"`
  echo "$str"

  注:当元字符"*"或者"."等位于字符集匹配"[]"后,便变成了一个普通的字符,只有
  字面意义,没有特殊意义.

6.字符不匹配集"[^]"
  符号"[^]"表示不匹配其中列出的任意字符,其语法如下:
  [^abc]

  其他一些元字符:
  1.  元字符:\(\)
      说明:定义子表达式的开始和结束位置.在后续正则表达式中可以通过转义序列来引用
      子正则表达式.最多可以定义9个子表达式,通过\1~\9来引用.
      举例:例如,正则表达式"\(love\).*\1"表示匹配两个"love"中间包括任意个
      字符的文本行,其中"\1"表示引用前面的"love"
  2.  元字符:x\{m,n\}c
      说明:区间表达式,匹配字符x重复的次数区间.其中x\{n\}表示最多重复n次,x\{m,\}
      表示最少重复m次,x\{m,n\}表示重复m~n次
      举例:例如,正则表达式"a\{2,3\}"表示字符a重复2~3次
  3.  元字符:\<
      说明:词首定位符
      举例:"\<hello"匹配含有以字符串"hello"开头的单词的文本行
  4.  元字符:\>
      说明:词尾定位符
      举例:"hello\>"匹配含有以字符串"hello"结尾的单词的文本行


拓展正则表达式
1.限定符"+"
  加法"+"的意义与限定符"*"基本相同,但是星号"*"限定前面的字符可以出现任意次(包括0),
  而加号"+"却限定前面的字符至少出现一次.
  #筛选以字符串"ss"开头,后面至少紧跟着一个字符"s"的文本行
  str=`ls ../test | egrep "^sss+"`
  echo "$str"
注:使用egrep命令而不是grep命令是因为grep命令使用的是基本正则表达式,而egrep使用的是
扩展正则表达式.

2.限定符"?"
  它用来限定前面的字符最多只出现一次,即前面的字符可以重复0次或者1次.
  echo "限定符?"
  #筛选以字符串"ss"开头,后面跟着0或者1个s的文本行
  str=`ls ../test | egrep "^sss?"`
  echo "$str"

3.竖线"|"和圆括号"()"
  竖线"|"表示多个正则表达式之间"或"的关系,其语法是:
  expression1|expression2|expression3|...|expressionn
  圆括号"()"用来表示一组可选值集合.竖线和圆括号经常一起使用,表示一组可选值.
  echo "竖线\"|\"和圆括号\"()\""
  #筛选含有字符串"ssh","ssl"或者字符串"yum"开头的文本行
  str=`ls /etc | egrep "(ssh|ssl|^yum)"`
  echo "$str"
注:方括号"[]"也可以表示一组可选字符集,例如[abc]表示匹配字符a,b或者c的任意一个
  等价于(a|b|c),另外下面三个表达式也是等价的:
  (Jeffrey|Jeffery)
  Jeff(rey|ery)
  Jeff(re|er)y

Perl正则表达式
1.数字匹配\d
  符号"\d"匹配0~9中任意一个数字字符,等价于"[0-9]"
2.非数字匹配\D
  符号"\D"和符号"\d"的作用正好相反,后者是匹配一个0~9之间的单个字符,前者则匹配一个
  非数字字符."\D"等价于表达式"[^0-9]"
3.空白字符匹配\s
  符号"\s"匹配任何空白字符,包括空格,制表符以及换页符等,等价于"[\f\n\r\t\v]".
4.费空白字符匹配\S
  符号"\S"匹配任何非空白字符,等价于"[^\f\n\r\t\v]".

正则表达式字符集
1.正则表达式的字符集通常使用方括号表达式表示,例如:
  [cC]hina      =>表示匹配"China"或者"china"这两个字符串
  [^hello]      =>表示不匹配"hello"这个字符串
  [a-zA-Z]      =>表示匹配所有的字母
  [0123456789]  =>表示匹配所有个位数字
  [0-9]         =>等价于[0123456789]
2.POSIX字符集
    [:alnum:]   =>匹配任意一个字母或者数字等价于A-Za-z0-9
    [:alpha:]   =>匹配任意一个字母,等价于A-Za-z
    [:digit:]   =>匹配任意一个数字,等价于0-9
    [:lower:]   =>匹配任意一个小写字母,等价于a-z
    [:upper:]   =>匹配任意一个大写字母,等价于A-Z
    [:space:]   =>匹配任意一个空白字符,包括空格,制表符,换行符,以及分页符等
    [:blank:]   =>匹配空格和制表符
    [:graph:]   =>匹配任意一个看得见的可打印字符,不包括空白字符
    [:print:]   =>匹配任意一个可打印字符,包括空白字符,但不包含控制字符,字符串结
                  束符"\0",EOF文件结束符(-1)
    [:cntrl:]   =>匹配任意一个控制字符,即ASCII字符集中前32个字符,例如换行符,
                  制表符等
    [:punct:]   =>匹配任意一个标点符号,例如"[]","{}"或者","等
    [:xdigit:]  =>匹配十六进制数字,即0-9,a-f,以及A-F
    与其他普通字符一样,上述字符类也需要放在方括号里,即[[:alnum]]等价于[a-zA-Z0-9]

正则表达式应用
  1.匹配单个字符
    1.1 单个一般字符
    所谓一般字符,指的是除了正则表达式中已经定义的元字符之外的所有字符,例如英文字符,
    数字,空白字符以及标点符号等.
    #搜索含有字符"a"的文本行
    str=`grep "a" note.txt`
    echo "$str"

    1.2 转义后的字符
    #搜索含有字符"."的文本行
    str=`grep "\." note.txt`
    echo "$str"

    1.3 圆点表达式
    即把1.2的"\."改为".",那样就表示匹配任意字符,会打印出所有的行

    1.4 方括号表达式
    如果在方括号的字符列表前面加上符号"^",表示取反.例如[^abc]表示不匹配"a","b"
    ,"c"三个字符中的中任意一个.
    当元字符位于方括号中时,除了极少数的几个元字符,例如连字符"-"或者"^"之外,其他
    元字符都将失去其特殊意义,而只保留字面意义,例如表达式"[\.]"表示的是反斜线"\"
    和圆点"."这两个字符,如果要匹配圆点,则只需要使用"[.]"即可

  2.匹配多个字符
    #搜索字符串"grep"
    #搜索字符串"grep"
    str=`grep "grep" note.txt`
    echo "$str"

    #匹配含有字符"o",后面紧跟着字符"r"或者"u"的文本行
    str=`grep "o[ru]" version.txt`
    echo "$str"

    #匹配任意多个字符"o"
    str=`grep "lo*king" version.txt`
    echo "$str"

    为了能够精确地表达前置字符重复出现的字符,用户还需要使用其他元字符.在基本正则
    表达式中,用户可以使用元字符"\{m,n\}"表示,而在拓展正则表达式和Prel正则表达
    式中,用户在使用前面的元字符时无需将花括号转义,直接使用"[m,n]"即可.其中参数
    m表示前置字符最少出现的次数,而参数n表示前置字符最多出现的次数.
    由元字符"{m,n}"可以衍生出另外两种表示方式.其中,元字符"{m}"表示前置字符出现
    m次,元字符"{m,}"表示前置字符至少出现m次
    在中国,免费电话号码的前缀是800,格式为 800-xxx-xxxx
    #筛选符合格式的电话号码
    str=`egrep "800-[[:digit:]]{3}-[[:digit:]]{4}$" ../test/phone.txt`
    echo "$str"
    注意:上述正则表达式一定要在最后加上"$"符号,不然最后一个电话号码(800-810-1818#)
    不会被滤掉

  3.匹配字符串的开头或者结尾
    如果行首定位符和行尾定位符一起使用,则这两个符号之间的表达试就匹配整个字符串或者
    文本行.如果"^"符号后面紧跟着"$"符号,即"^$",则表示一个空行.因为行首后面紧跟着
    行尾,行中没有任何字符.
    #筛选以3个数字开头的文本行
    str=`egrep "^[[:digit:]]{3}" ../test/phone.txt`
    echo "$str"
    #筛选以4个数字结尾的文本行
    str=`egrep "[[:digit:]]{4}$" ../test/phone.txt`
    echo "$str"

  4.运算符优先级
    由高到低:
    \
    []
    ()
    * , + , ? , {m} , {m,} , {m,n}
    普通字符
    ^ , $
    |

  5.子表达式
    #通过正则表达式定位所有的2个连续的HTML空格符
    str=`egrep "(&nbsp;){2}" html.txt`
    echo "$str"
    而不是 str=`egrep "&nbsp;{2}" html.txt`  这样就变为匹配&nbsp后面有两个;了

    #匹配IP地址
    str=`egrep "^([[:digit:]]{1,3}\.){3}[[:digit:]]{1,3}$" ../test/ip.txt`
    echo "$str"
    注解:[[:digit:]]{1,3}\.是一个子表达式,表示匹配1~3个数,然后是一个圆点.整个表达式
    描述的字符串以3组重复的1~3个数字后跟着一个圆点开头,然后以1~3个数字结束.
    假设输出如下:
    202.116.3.2
    10.0.0.1
    256.45.2.1
    可以看出256超出了0~255,并不合法,所以还是有问题.
    #匹配合法IP地址
    str=`egrep "^([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])$" ../test/ip.txt`
    echo "$str"

  6.通配符
    ls -l ex*            列出所有以ex开头的文件名
    ls -l [de]*          列出所有以d或者e开头的文件名
    ls -l exam_[1-9].sh  列出以exam_开头,然后编号1~9,接着是.sh的文件名


grep命令
  基本语法 grep [option] pattern [file...]
  option表示选项,pattern表示匹配的模式,file表示一系列文件名

  [options]主要参数：
    －c：只输出匹配行的计数。
    －i：不区分大 小写(只适用于单字符)。
    －h：查询多文件时不显示文件名。
    －l：查询多文件时只输出包含匹配字符的文件名。
    －n：显示匹配行及行号。
    －s：不显示不存在或无匹配文本的错误信息。
    －v：显示不包含匹配文本的所有行。
    -r :递归搜索,不仅搜索当前目录,还要搜索其各级子目录
    -w :匹配整个单词
    -x :匹配整个文本行
    -q :禁止输出任何任何匹配结果,而是以退出状态码的形式表示搜索是否成功,其中0表示找到了匹配文本行
    -b :打印匹配的文本行到文本头的偏移量,以字节为单位
    -E :支持扩展正则表达式
    -P :支持Perl正则表达式
    -F :不支持正则表达式,将模式按字面意思匹配 

  pattern正则表达式主要参数：
    \： 忽略正则表达式中特殊字符的原有含义。
    ^：匹配正则表达式的开始行。
    $: 匹配正则表达式的结束行。
    \<：从匹配正则表达 式的行开始。
    \>：到匹配正则表达式的行结束。
    []：单个字符，如[A]即A符合要求 。
    [-]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。
    * ：有字符，长度可以为0。






#=======================================结束====================================#c
